---
sidebar_position: 10
title: Aggregator
slug: .
---

import MarkdownImage from "/src/components/MarkdownImage";
import Link from "@docusaurus/Link";
import { Typography, Box, Grid } from "@mui/material";

import AggregatorInstructions from "/idl/_aggregator_instructions.mdx";

import AggregatorAccountData from "/idl/accounts/AggregatorAccountData.md";

import JobInstructions from "/idl/_job_instructions.mdx";

<MarkdownImage
  img="/img/L2_Aggregator_Accounts.png"
  sx={{
    maxHeight: { sm: "100%", md: "400px" },
  }}
/>

An aggregator or data feed is what on-chain developers use when building smart contracts. A data feed is a collection of jobs that get aggregated to produce some deterministic result. Each job is associated with an endpoint and has a number of tasks that get executed in sequential order in order to produce a single value. Typically the first task in a job will fetch external data with subsequent tasks responsible for parsing the response and transforming the value into a single data type, like an integer or decimal. When an oracle is assigned to process a data feed update, the oracle executes the defined jobs and publishes the median result on-chain. The data feed then computes the final value as the median response among the assigned oracles. In summary, the data feed is the blueprint for how data gets fetched from off-chain sources.

Along with the jobs, a data feed also includes a configuration dictating how often a feed should be updated and the minimum number of jobs or oracles that must respond before accepting a result. The publisher is ultimately responsible for building a data feed and making the necessary trade-offs as it‚Äôs a careful balance between cost and update interval. The publisher is usually the on-chain consumer of the data and will have the most familiarity with how the data may be used to make these considerations.

## Functions

An aggregator is responsible for the following functions:

- <Link to="#job-definitions">
    <b>Job Definitions: </b>
  </Link>
  Defines how a result is calculated by an oracle.
- <Link to="#oracle-consensus">
    <b>Oracle Consensus: </b>
  </Link>
  Defines how a result is accepted on-chain by a set of oracle responses.
- <Link to="#update-requests">
    <b>Update Requests: </b>
  </Link>
  Defines how an update can be requested.
- <Link to="#update-requests">
    <b>Oracle Rewards: </b>
  </Link>
  Rewards oracles for successfully completing an update request.

### üöÄJob Definitions

An aggregator stores a list of JobAccount public keys in `jobPubkeysData`, as well as the current size `jobPubkeysSize`, the hashes of the jobs in `jobHashes` to prevent malicious RPC nodes from swapping out job definitions, and their checksums in `jobsChecksum`.

An aggregator's config also includes `minJobResults` which determines how many jobs must respond before an oracle responds on-chain. This is useful if you have an endpoint that may be unreliable and you don't want it to affect the oracle response.

[See /architecture/feeds/job for more info](/architecture/feeds/job)

#### Private APIs

Job definitions support injecting environment variables from the oracle into the tasks before execution. This functionality requires a private oracle queue because the API keys must be provided to each oracle fulfilling an update request thus requires a higher level of trust between the oracle and the API key owner.

### üöÄOracle Consensus

An aggregator must specify an `oracleRequestBatchSize` which determines how many oracles get assigned to each update request. This induces extra cost on each update request but requires a higher degree of oracle collusion to affect the accepted on-chain result.

An aggregator also specifies `minOracleResults` which is the number of oracles that must respond before a value is accepted on-chain.

### üöÄUpdate Requests

An aggregator has a number of config options which dictate whether an update request is valid. An aggregator can specify `startAfter` to only allow update request after a given unix timestamp. An aggregator can also specify `expiration` to only allow update request before a given unix timestamp. An aggregator must specify `minUpdateDelaySeconds` which enforces a minimum update delay between requests.

#### Manual

An aggregator can be updated by anyone by invoking the open round instruction. If a request is considered valid, it is assigned to a batch of oracles.

#### Crank

An aggregator with valid queue permissions can decide to join a queues crank. A crank is a collection of aggregator public keys, ordered by their next available update, with some level of jitter added to prevent a predictable oracle allocation cycle. Anyone can turn a crank and be rewarded if any update requests are successful.

### üöÄReward Oracles

An aggregator uses a [Lease Contract](/architecture/feeds/lease) to reward oracles each time an update request is fulfilled. The lease contract amount is derived from an aggregator's `minUpdateDelaySeconds`, `oracleRequestBatchSize`, and the oracle queue's specified `reward`.

## Account Schema

### üì¶AggregatorAccountData

<AggregatorAccountData />

## More Info

- <Link className="link__nocolor" to="/publisher">
    ‚ÑπÔ∏è Publisher
  </Link>
- <Link className="link__nocolor" to="/feed/directory">
    ‚ÑπÔ∏è Job Directory
  </Link>
